#include "Nivel.h"
#include <cassert>
#include <iostream>
#include <fstream>
#include <cmath>

using namespace std;

Nivel::Nivel()
{
}

Nivel::Nivel(int ancho, int alto, int soles, std::vector<VampiroEnEspera>& spawninglist)
{
	//vectores _flores y _vampiros no se agregan aca, empiezan vacias 
	
	/* Si alguno de los valores no está en el rango del invariante o la longitud de spawninglist no es
	 * la debida crea un "nivel estandar" con los valores minimos qye cumplen.
	 */

	if(valoresDeEntradaEnRango(ancho,alto,soles,spawninglist.size())){
	
		this->_ancho = ancho;
		this->_alto = alto;
		this->_soles = soles;	
		this->_spawning = ordenarSpawning(spawninglist); // Se cumple invariante de spawningOrdenado
	
	} else {

		this->_ancho = 1;
		this->_alto = 1;
		this->_soles = 0;
		
		Vampiro vamp(Caminante,0,1);

		VampiroEnEspera vampEnEspera(vamp,1,1);
		
		std::vector<VampiroEnEspera> spaw;
		spaw.push_back(vampEnEspera);

		this->_spawning = spaw;
	}

	this->_turno = 0;
	this->_vampiros = std::vector<VampiroEnJuego>();
	this->_flores = std::vector<FlorEnJuego>();

}

int Nivel::anchoN()
{
	return _ancho;
}

int Nivel::altoN()
{
	return this->_alto;
}

int Nivel::turnoN()
{
	return this->_turno;
}

int Nivel::solesN()
{
	return this->_soles;
}

std::vector<FlorEnJuego>& Nivel::floresN()
{
	return this->_flores;
}

std::vector<VampiroEnJuego>& Nivel::vampirosN()
{
	return this->_vampiros;
}

std::vector<VampiroEnEspera>& Nivel::spawningN()
{
	return this->_spawning;
}

void Nivel::comprarSoles(int s){
	// requiere s > 0
	if(s > 0)
		this->_soles = this->_soles + s;
}

void Nivel::agregarFlor(Flor f, Posicion p)
{
	// Verifico que se cumpla el invariante de necesitoMiEspacio y que haya soles suficientes:
	int i = 0;
	int valor = pow(2, (f.habilidadesF().size()));
	bool hayEspacio = true;

	if(this->_soles >= valor){

		while(i < this->_flores.size()){
			if(mismaPosicion(this->_flores.at(i).pos, p)){
				hayEspacio = false;
			}
			i++;
		}

		if(hayEspacio){
			this->_soles = this->_soles - valor;
			std::vector<FlorEnJuego> flores = std::vector<FlorEnJuego>();
			FlorEnJuego florEnJuego = FlorEnJuego(f, p, f.vidaF());
			flores.push_back(florEnJuego);
			i = 0;
			while(i < this->_flores.size()){
				flores.push_back(this->_flores.at(i));
				i++;	
			}
			this->_flores = flores;
		}
	}
}

void Nivel::pasarTurno()
{
	Habilidad habilidad = Generar;
	this->_soles = this->_soles + cantidadFloresConHabilidad(habilidad) + 1;
	int i = 0;
	vector<FlorEnJuego> flores = vector<FlorEnJuego>();
	vector<VampiroEnJuego> vampiros = this->_vampiros;
	while(i < this->_flores.size()){
		FlorEnJuego florEnJuego = this->_flores.at(i);
		if(!florMuerta(florEnJuego, vampiros)){
			flores.push_back(florEnJuego);
		}
		i++;
	}
	this->_flores = flores;
	
	i = 0;
	vampiros = vector<VampiroEnJuego>();
	while(i < this->_vampiros.size()){
		VampiroEnJuego vampiroEnJuego = this->_vampiros.at(i);
		if(!vampiroMuerto(vampiroEnJuego, this->_flores, this->_vampiros)){
			vampiros.push_back(daniarVampiro(vampiroEnJuego, this->_flores, this->_vampiros));
		}
		i++;
	}
	vector<VampiroEnJuego> nuevosVampirosDeTurno = nuevosVampiros();
	i = 0;
	while(i < nuevosVampirosDeTurno.size()){
		vampiros.push_back(nuevosVampirosDeTurno.at(i));
		i++;
	}	
	i = 0;
	vector<VampiroEnEspera> proximosVampirosDeTurno = vector<VampiroEnEspera>();
	while(i < this->_spawning.size()){
		if(this->_spawning.at(i).turno > this->_turno + 1){
			proximosVampirosDeTurno.push_back(this->_spawning.at(i));
		}
		i++;
	}
	this->_spawning = ordenarSpawning(proximosVampirosDeTurno);
	this->_turno = this->_turno + 1;
}

bool Nivel::terminado()
{
	return (this->_vampiros.empty() && this->_spawning.empty()) || vampirosEnCasa(this->_vampiros) > 0;	
}

bool Nivel::ganado(){
	return (this->_vampiros.empty() && this->_spawning.empty()) && vampirosEnCasa(this->_vampiros) == 0;
}

bool Nivel::obsesivoCompulsivo()
{
	vector<FlorEnJuego> ord = this->_flores;
	int i=0, j;
	FlorEnJuego temp;
	bool res = true;

	if(this->_flores.size() > 0){

		while (i < ord.size()) {
			j=i+1;
			
			while (j < ord.size()){
				if (ord[j].pos.fila < ord[i].pos.fila ||
				(ord[j].pos.fila == ord[i].pos.fila &&
				ord[j].pos.columna < ord[i].pos.columna)){
					temp = ord[i];
					ord[i] = ord[j];
					ord[j] = temp;
				}
				j++;
			}
			i++;
		}

	    i = 0;
		while (i < ord.size()-1){
			if (florAtaca(ord[i])==florAtaca(ord[i+1])){
					res = false;
				}
			i++;
		}
		
	} else {
		res = false;
	}
	return res;
}


bool Nivel::florAtaca (FlorEnJuego f){
	int i=0;
	bool res = false;
	
	while (i < f.flor.habilidadesF().size()) {
		if (f.flor.habilidadesF()[i]==Atacar)
			res = true;
		i++;
	}
	return res;
}

void Nivel::Mostrar(std::ostream& os)
{	
	int i = 0;

	os << "INFO. DEL NIVEL:" << endl;
	os << "Ancho del NIVEL: " << this->_ancho << endl;
	os << "Alto del NIVEL: " << this ->_alto << endl;
	os << "Turno del NIVEL: " << this->_turno << endl;
	os << "Soles del NIVEL: " << this->_soles << endl << endl;

	//Muestro las flores del nivel
	os << "** Flores del NIVEL **" << endl;
	
	while(i < this->_flores.size()){
		
		os << endl;

		_flores.at(i).flor.Mostrar(os);

		os << "Posición en NIVEL:" << endl;
		os << "Fila: " << _flores.at(i).pos.fila << "  //  Columna: " << _flores.at(i).pos.columna << endl;
		os << "Vida de la flor en el NIVEL: " << _flores.at(i).vida << endl;
		
		i++;
	}

	i = 0;

	//Muestro los vampiros en juego del nivel
	os << endl << "** Vampiros del NIVEL **" << endl;

	while(i < this->_vampiros.size()){

		os << endl;

		_vampiros.at(i).vampiro.Mostrar(os);

		os << "Posición en NIVEL:" << endl;
		os << "Fila: " << _vampiros.at(i).pos.fila << "  //  Columna: " << _vampiros.at(i).pos.columna << endl;
		os << "Vida del vampiro en el NIVEL: " << _vampiros.at(i).vida << endl;

		i++;		
	}

	i = 0;
	
	//Muestro la lista de spawning del nivel
	os << endl << "** Lista del Spawning del NIVEL **" << endl;

	while(i < this->_spawning.size()){

		os << endl;

		_spawning.at(i).vampiro.Mostrar(os);

		os << "Fila en que aparece: " << _spawning.at(i).fila << endl;
		os << "Turno en que aparece: " << _spawning.at(i).turno << endl;

		i++; 
	}
}

void Nivel::Guardar(std::ostream& os)
{
	os << "{ N ";
	os << this->_ancho << " ";
	os << this->_alto << " ";
	os << this->_turno << " ";
	os << this->_soles << " [ ";

	if(_flores.size() == 0){
		os << "] ";
	} else {
		int i = 0;
		while(i < _flores.size()){
			_flores.at(i).flor.Mostrar(os);
			os << " ";
			i++;
		}
		os << "] ";
	}

	os << "[ ";

	if(_vampiros.size() == 0){
		os << "] ";
	} else {
		int j = 0;
		while(j < _vampiros.size()){
			_vampiros.at(j).vampiro.Mostrar(os);
			os << " (";
			os << _vampiros.at(j).pos.fila << " ";
			os << _vampiros.at(j).pos.columna << " )";
			j++;
		}
		os << " ] ";
	}

	os << "[ ";

	if(_spawning.size() == 0){
		os << "] ";
	} else {
		int k = 0;
		while(k < _spawning.size()){
			os << "( ";
			_spawning.at(k).vampiro.Mostrar(os);
			os << " ";
			os << _spawning.at(k).fila << " ";
			os << _spawning.at(k).turno << " ";
			k++;
			os << ") ";
		}
		os << "] }";
	}
}

void Nivel::Cargar(std::istream& is)
{

	string leer,x;
	int i,posX,posY,vidaFlor,vidaVamp,vidaVampJuego,cPVamp,filaVamp,turnoVamp;
	vector<Habilidad> hs;
	ClaseVampiro claseVamp;


	while(is >> leer){

		//cargo los primeros datos del nivel
		if(leer == "N"){
			
			getline(is,x,' ');
			getline(is,x,' ');
			this->_ancho = atoi(x.c_str());
			
			getline(is,x,' ');
			this->_alto = atoi(x.c_str());
			
			getline(is,x,' ');
			this->_turno = atoi(x.c_str());

			getline(is,x,' ');
			this->_soles = atoi(x.c_str());
			
		} // fin de la carga de ancho,alto,turno y soles
		
		//cargo las flores en juego
		else if(leer == "F"){
			
			getline(is,x,'[');
			getline(is,x,']');
			i = 0;
			
			//reviso que habilidades tiene la flor para crearla
			while(i < x.length()){
				if(x[i] == 'A'){
					hs.push_back(Atacar);
				} else if(x[i] == 'G') {
					hs.push_back(Generar);
				} else if(x[i] == 'E'){
					hs.push_back(Explotar);
				}

				i++;
			}

			Flor f(1,1,hs);

			getline(is,x,'(');
			getline(is,x,' ');
			getline(is,x,' ');
			//aca estoy en la posicion x de la tupla

			posX = atoi(x.c_str());

			getline(is,x,' ');

			posY = atoi(x.c_str());

			Posicion pos(posX,posY);

			//ahora la vida de la flor en juego
			getline(is,x,')');
			getline(is,x,' ');

			vidaFlor = atoi(x.c_str());

			//creo la FlorEnJuego y la agrego en el vector
			FlorEnJuego fEnJuego(f,pos,vidaFlor);
			this->_flores.push_back(fEnJuego);

		} // fin de la carga de flor en juego

		//cargo los vampiros en juego
		else if(leer == "V"){
			
			//primero creo el vampiro que hay, despues me fijo a que lista pertenece
			getline(is,x,' ');

			if(x == "Desviado"){
				claseVamp = Desviado;
			} else if(x == "Caminante") {
				claseVamp = Caminante;
			}

			getline(is,x,' ');
			vidaVamp = atoi(x.c_str());

			getline(is,x,' ');
			cPVamp = atoi(x.c_str());

			//creo el vampiro
			Vampiro vamp(claseVamp,vidaVamp,cPVamp);

			//me fijo si hay una tupla o no, eso va a decir si estoy en la lista de vampiros
			//o en la lista de spam.
			getline(is,x,'}');
			getline(is,x,' ');
			getline(is,x,' ');

			if(x == "("){ //esto me muestra que es parte de los vampiros del juego
				
				getline(is,x,' ');
				posX = atoi(x.c_str());

				getline(is,x,' ');
				posY = atoi(x.c_str());

				Posicion pos(posX,posY);

				getline(is,x,' ');
				getline(is,x,' ');
				vidaVampJuego = atoi(x.c_str());

				VampiroEnJuego vEnJuego(vamp,pos,vidaVampJuego);
				this->_vampiros.push_back(vEnJuego);
			
			} else { //esto muestra que es parte del spawning

				filaVamp = atoi(x.c_str());

				getline(is,x,' ');
				turnoVamp = atoi(x.c_str());

				VampiroEnEspera vEnEspera(vamp,filaVamp,turnoVamp);
				this->_spawning.push_back(vEnEspera);

			}

		} // fin de la carga del vampiro

	}// fin del while que recorre el ifstream

}

std::vector<VampiroEnEspera> Nivel::ordenarSpawning(std::vector<VampiroEnEspera> spawning){
	std::vector<VampiroEnEspera> spawningFinal = std::vector<VampiroEnEspera>();
	std::vector<VampiroEnEspera> spawningAuxiliar = spawning;
	int i = 0;
	while(i < spawning.size()){
		int j = 0;
		while(j < spawning.size()){
			VampiroEnEspera spawningSeleccionado = spawningAuxiliar.at(j);
			if(tieneTurnoMinimo(spawningSeleccionado, spawningAuxiliar)){
				spawningFinal.push_back(spawningSeleccionado);	
				spawningAuxiliar = eliminarSpawning(spawningAuxiliar, spawningSeleccionado);
				break;
			}
			j++;
		}
		i++;
	}
	return spawningFinal;
}

bool Nivel::tieneTurnoMinimo(VampiroEnEspera v1, std::vector<VampiroEnEspera> spawning){
	bool result = true;
	int i = 0;
	while(i < spawning.size()){
		if(spawning.at(i).turno < v1.turno || (spawning.at(i).turno == v1.turno && spawning.at(i).fila < v1.fila)){
			result = false;
			break;
		}
		i++;
	}	
	return result;
}

std::vector<VampiroEnEspera> Nivel::eliminarSpawning(std::vector<VampiroEnEspera> lista, VampiroEnEspera vampiro){
	std::vector<VampiroEnEspera> listaReturn = std::vector<VampiroEnEspera>();
	int i = 0;	
	while(i < lista.size()){
		if(!igualesVampiros(lista.at(i), vampiro)){
			listaReturn.push_back(lista.at(i));	
		}
		i++;	
	}
	return listaReturn;
}

bool Nivel::igualesVampiros(VampiroEnEspera v1, VampiroEnEspera v2){
	if(v1.vampiro.claseV() == v2.vampiro.claseV() &&
			v1.fila == v2.fila &&
			v1.turno == v2.turno){
		return true;
	}
	return false;
}

int Nivel::cantidadFloresConHabilidad(Habilidad habilidad){
	std::vector<FlorEnJuego> floresConHabilidad = std::vector<FlorEnJuego>();
	int i = 0;
	while(i < this->_flores.size()){
		FlorEnJuego florSeleccionada = this->_flores.at(i);
		std::vector<Habilidad> habilidadesFlorSeleccionada = florSeleccionada.flor.habilidadesF();
		int j = 0;
		while(j < habilidadesFlorSeleccionada.size()){
			if(habilidadesFlorSeleccionada.at(j) == habilidad){
				floresConHabilidad.push_back(florSeleccionada);
				break;
			}	
		}	
		i++;	
	}
	return floresConHabilidad.size();
}

int Nivel::vampirosEnCasa(std::vector<VampiroEnJuego> vampiros){
	int result = 0;
	int i =	0;
	while(i < vampiros.size()){
		VampiroEnJuego vampiro = vampiros.at(i);
		if(vampiro.pos.fila == 0){
			result++;	
		}
		i++;	
	}	
	return result;
}

bool Nivel::valoresDeEntradaEnRango(int ancho, int alto, int soles, int spawnSize){
	return ancho > 0 && alto > 0 && soles >= 0 && spawnSize > 0;
}

FlorEnJuego Nivel::daniarFlor(FlorEnJuego flor, vector<VampiroEnJuego> vampiros){
	
	FlorEnJuego res = FlorEnJuego(flor.flor, flor.pos, flor.vida);
	int danioTotal = 0;
	int i = 0;
	while(i < vampiros.size()){
		VampiroEnJuego vej = vampiros.at(i);
		if(mismaPosicion(vej.pos, flor.pos)){
			danioTotal += vej.vampiro.cuantoPegaV();
		}
		i++;
	}
	res.vida = res.vida - danioTotal;	
	return res;
}

bool Nivel::florMuerta(FlorEnJuego flor, vector<VampiroEnJuego> vampiros){
	return (florExploto(flor, vampiros) || daniarFlor(flor, vampiros).vida <= 0);
}

bool Nivel::florExploto(FlorEnJuego flor, vector<VampiroEnJuego> vampiros){
	Habilidad hab = Explotar;
	return (tieneHabilidad(flor, hab) && vampiroEnMismaPosicion(flor, vampiros));
}

bool Nivel::tieneHabilidad(FlorEnJuego florEnJuego, Habilidad habilidad){
	int i = 0;
	vector<Habilidad> habilidades = florEnJuego.flor.habilidadesF();
	while(i < habilidades.size()){
		if(habilidades.at(i) == habilidad){
			return true;
		}
		i++;
	}
	return false;
}

bool Nivel::vampiroEnMismaPosicion(FlorEnJuego florEnJuego, vector<VampiroEnJuego> vampiros){
	int i = 0;
	while(i < vampiros.size() && !mismaPosicion(vampiros.at(i).pos, florEnJuego.pos)){
		i++;
	}
	return i < vampiros.size();
}

bool Nivel::vampiroMuerto(VampiroEnJuego vampiro, vector<FlorEnJuego> flores, vector<VampiroEnJuego> vampiros){
	return daniarVampiro(vampiro, flores, vampiros).vida <= 0;
}

VampiroEnJuego Nivel::daniarVampiro(VampiroEnJuego vampiroEnJuego, vector<FlorEnJuego> flores, vector<VampiroEnJuego> vampiros){
	VampiroEnJuego vampiro = VampiroEnJuego(vampiroEnJuego.vampiro, vampiroEnJuego.pos, vampiroEnJuego.vida);
	int i = 0;
	int danioTotal = 0;
	while(i < flores.size()){
		if(enMira(flores.at(i), vampiro) && !intercepta(flores.at(i), vampiro, vampiros)){
			danioTotal += flores.at(i).flor.cuantoPegaF();
		}
		i++;
	}
	vampiro.vida = vampiro.vida - danioTotal;
}

bool Nivel::enMira(FlorEnJuego flor, VampiroEnJuego vampiro){
	return flor.pos.fila == vampiro.pos.fila && flor.pos.columna <= vampiro.pos.columna;
}

bool Nivel::intercepta(FlorEnJuego flor, VampiroEnJuego vampiro, vector<VampiroEnJuego> vampiros){
	bool res = false;
	int i = 0;
	while(i < vampiros.size()){
		if(vampiros.at(i).pos.fila == flor.pos.fila && flor.pos.columna <= vampiros.at(i).pos.columna && vampiros.at(i).pos.columna < vampiro.pos.columna){
			res = true;
		}
		i++;
	}
	return res;
}

vector<VampiroEnJuego> Nivel::nuevosVampiros(){
	int i = 0;
	vector<VampiroEnJuego> nuevosVamps = vector<VampiroEnJuego>();
	while(i < this->_spawning.size()){
		VampiroEnEspera vee = this->_spawning.at(i);
		if(vee.turno == (this->_turno + 1)){
			Posicion pos = Posicion(this->_ancho, vee.fila);
			VampiroEnJuego vej = VampiroEnJuego(vee.vampiro, pos, vee.vampiro.vidaV());
			nuevosVamps.push_back(vej); 
		}
		i++;
	}
	return nuevosVamps;
}

bool Nivel::mismaPosicion(Posicion p1, Posicion p2){
	return p1.fila == p2.fila && p1.columna == p2.columna;
}

void Nivel::setVampiros(vector<VampiroEnJuego> vampiros){
	this->_vampiros = vampiros;
}
